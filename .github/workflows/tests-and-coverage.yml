name: Test and Coverage Check

on:
  workflow_run:
    workflows: ["Static Checks"]
    types: [completed]
  # Execução direta em push (para garantir que sempre rode)
  push:
    branches: ["master", "main", "develop", "feature/*"]
  pull_request:
    branches: ["master", "main", "develop"]
  workflow_dispatch:

permissions:
  contents: write

env:
  NODE_VERSION: 20.x

jobs:
  test-backend:
    name: Test Backend
    if: >-
      ${{ github.event_name == 'workflow_dispatch' || 
          github.event_name == 'push' || 
          github.event_name == 'pull_request' ||
          (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: backend/package-lock.json
      - name: Install backend deps
        working-directory: backend
        run: npm ci || npm install
      - name: Run Backend Tests (unit + integration)
        working-directory: backend
        run: |
          npx jest --config jest.config.unit.js --coverage --coverageDirectory coverage-unit --reporters=default \
            --coverageReporters=text --coverageReporters=lcov --coverageReporters=json-summary
          if [ -f jest.config.integration.js ]; then npx jest --config jest.config.integration.js; fi
      - name: Upload Backend Coverage
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: backend/coverage-unit/

  test-frontend:
    name: Test Frontend
    if: >-
      ${{ github.event_name == 'workflow_dispatch' || 
          github.event_name == 'push' || 
          github.event_name == 'pull_request' ||
          (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: frontend/package-lock.json
      - name: Install frontend deps
        working-directory: frontend
        run: npm ci || npm install
      - name: Run Frontend Tests (CRA Jest)
        working-directory: frontend
        env:
          CI: true
        run: |
          npm test -- --coverage --watchAll=false \
            --coverageReporters=text --coverageReporters=lcov --coverageReporters=json-summary
      - name: Upload Frontend Coverage
        uses: actions/upload-artifact@v4
        with:
          name: frontend-coverage
          path: frontend/coverage/

  coverage-gate:
    name: Coverage Gate (>=80%)
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    if: ${{ always() && (
        github.event_name == 'push' ||
        github.event_name == 'pull_request' ||
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      ) }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
      - name: Download Coverage Artifacts
        uses: actions/download-artifact@v4
        with:
          path: coverage-artifacts
      - name: Combine & Enforce Coverage + Generate Badges (pass/fail)
        run: |
          export BACKEND_FILE=$(find coverage-artifacts/backend-coverage -name 'coverage-summary.json' | head -n1)
          export FRONTEND_FILE=$(find coverage-artifacts/frontend-coverage -name 'coverage-summary.json' | head -n1)
          node <<'EOF'
          const fs = require('fs');
          const backendPath = process.env.BACKEND_FILE;
          const frontendPath = process.env.FRONTEND_FILE;
          if(!backendPath || !frontendPath){
            console.error('Missing backend or frontend coverage summary files');
            fs.mkdirSync('combined-coverage',{recursive:true});
            fs.writeFileSync('combined-coverage/coverage-gate-badge.json', JSON.stringify({schemaVersion:1,label:'coverage gate',message:'fail',color:'red',error:'missing summary files'}));
            process.exit(1);
          }
          const b = JSON.parse(fs.readFileSync(backendPath,'utf8'));
          const f = JSON.parse(fs.readFileSync(frontendPath,'utf8'));
          function mergeMetric(a,b){return { total:a.total + b.total, covered:a.covered + b.covered, skipped:(a.skipped||0)+(b.skipped||0) };}
          const metrics = Object.keys(b.total);
          const result = { total:{} };
          for(const m of metrics){
            const merged = mergeMetric(b.total[m], f.total[m]);
            merged.pct = (merged.covered/merged.total*100).toFixed(2);
            result.total[m]=merged;
          }
          const thresholds = { lines:80, statements:80, functions:80, branches:80 };
          let sum=0,count=0; const failures=[];
          for(const k of Object.keys(thresholds)){
            const pct=parseFloat(result.total[k].pct); sum+=pct; count++;
            if(pct < thresholds[k]) failures.push(`${k}=${pct}`);
          }
          const avg=(sum/count).toFixed(2);
          fs.mkdirSync('combined-coverage',{recursive:true});
          fs.writeFileSync('combined-coverage/combined-coverage-summary.json', JSON.stringify(result,null,2));
          const coverageBadge = { schemaVersion:1, label:'coverage', message: avg+'%', color: parseFloat(avg)>=90?'brightgreen':(parseFloat(avg)>=80?'green':'orange') };
          fs.writeFileSync('combined-coverage/coverage-badge.json', JSON.stringify(coverageBadge));
          const pass = failures.length === 0;
          const gateBadge = pass
            ? { schemaVersion:1, label:'coverage gate', message:'pass', color:'green' }
            : { schemaVersion:1, label:'coverage gate', message:'fail', color:'red', failed: failures };
          fs.writeFileSync('combined-coverage/coverage-gate-badge.json', JSON.stringify(gateBadge));
          if(!pass){
            console.error('Coverage gate failed metrics: '+failures.join(', '));
            process.exit(1);
          }
          console.log('Coverage gate passed. Average coverage:', avg+'%');
          EOF
      - name: Upload Combined Coverage
        uses: actions/upload-artifact@v4
        with:
          name: combined-coverage
          path: combined-coverage
      - name: Upload Coverage Badge JSON
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: combined-coverage/coverage-badge.json
      - name: Upload Coverage Gate Badge JSON
        uses: actions/upload-artifact@v4
        with:
          name: coverage-gate-badge
          path: combined-coverage/coverage-gate-badge.json
      - name: Coverage Summary Output
        run: |
          AVG=$(node -e "const d=require('./combined-coverage/coverage-badge.json');process.stdout.write(d.message)")
          echo "### Coverage Badge" >> $GITHUB_STEP_SUMMARY
          echo "Cobertura média combinada: ${AVG}" >> $GITHUB_STEP_SUMMARY
          echo "Badges e histórico publicados na branch 'badges'." >> $GITHUB_STEP_SUMMARY
      - name: Publish Coverage + History Badges (all branches)
        env:
          BADGE_BRANCH: badges
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch || github.ref_name }}
        run: |
          set -euo pipefail
          SAFE_BRANCH=$(echo "$HEAD_BRANCH" | tr '/:' '--')
          git fetch origin $BADGE_BRANCH || true
          if git show-ref --verify --quiet refs/remotes/origin/$BADGE_BRANCH; then
            git checkout $BADGE_BRANCH
            git reset --hard origin/$BADGE_BRANCH
          else
            git checkout --orphan $BADGE_BRANCH
            git rm -rf . 2>/dev/null || true
            rm -rf * .[^.]* 2>/dev/null || true
          fi
          mkdir -p badges/history
          cp combined-coverage/coverage-badge.json badges/coverage-badge.json
          cp combined-coverage/coverage-badge.json badges/coverage-badge-${SAFE_BRANCH}.json
          if [ -f combined-coverage/coverage-gate-badge.json ]; then
            cp combined-coverage/coverage-gate-badge.json badges/coverage-gate-badge.json
            cp combined-coverage/coverage-gate-badge.json badges/coverage-gate-badge-${SAFE_BRANCH}.json
          fi
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          AVG_VAL=$(node -e "const d=require('./combined-coverage/coverage-badge.json');process.stdout.write(d.message.replace('%',''))")
          echo "{\"timestamp\":\"$TIMESTAMP\",\"branch\":\"$HEAD_BRANCH\",\"safeBranch\":\"$SAFE_BRANCH\",\"coverage\":$AVG_VAL}" > /tmp/history-entry.json
          if [ -f badges/history/coverage-history.json ]; then
            node -e "const fs=require('fs');const f='badges/history/coverage-history.json';let a=[];try{a=JSON.parse(fs.readFileSync(f,'utf8'));if(!Array.isArray(a))a=[];}catch(e){};const e=JSON.parse(fs.readFileSync('/tmp/history-entry.json','utf8'));a.push(e);if(a.length>500)a=a.slice(-500);fs.writeFileSync(f,JSON.stringify(a,null,2));"
          else
            cp /tmp/history-entry.json badges/history/coverage-history.json
          fi
          if [ -f badges/history/coverage-history-${SAFE_BRANCH}.json ]; then
            node -e "const fs=require('fs');const f='badges/history/coverage-history-${SAFE_BRANCH}.json';let a=[];try{a=JSON.parse(fs.readFileSync(f,'utf8'));if(!Array.isArray(a))a=[];}catch(e){};const e=JSON.parse(fs.readFileSync('/tmp/history-entry.json','utf8'));a.push(e);if(a.length>200)a=a.slice(-200);fs.writeFileSync(f,JSON.stringify(a,null,2));"
          else
            cp /tmp/history-entry.json badges/history/coverage-history-${SAFE_BRANCH}.json
          fi
          cp /tmp/history-entry.json badges/history/coverage-latest-${SAFE_BRANCH}.json
          echo '{"info":"Coverage badge files"}' > badges/index.json
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add badges/*.json badges/history/*.json || true
          if git diff --cached --quiet; then
            echo "No badge changes";
          else
            git commit -m "chore(badges): update coverage + history ($HEAD_BRANCH)"
            git push origin HEAD:$BADGE_BRANCH || echo "WARN: push blocked"
          fi

  update-readme-badges:
    name: Update README badges section
    needs: [coverage-gate]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
      - name: Update README badge block (dynamic branch)
        env:
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch || github.ref_name }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          SAFE_BRANCH=$(echo "$HEAD_BRANCH" | tr '/:' '--')
          BADGES_URL="https://raw.githubusercontent.com/${REPO}/badges/badges"
          BUILD_URL="${BADGES_URL}/build-status-badge-${SAFE_BRANCH}.json"
          COV_URL="${BADGES_URL}/coverage-badge-${SAFE_BRANCH}.json"
          GATE_URL="${BADGES_URL}/coverage-gate-badge-${SAFE_BRANCH}.json"
          echo "<!-- BADGES-AUTO-START -->" > /tmp/_badges.md
          echo "![Build (${HEAD_BRANCH})](https://img.shields.io/endpoint?url=${BUILD_URL})" >> /tmp/_badges.md
          echo "![Coverage (${HEAD_BRANCH})](https://img.shields.io/endpoint?url=${COV_URL})" >> /tmp/_badges.md
          echo "![Coverage Gate (${HEAD_BRANCH})](https://img.shields.io/endpoint?url=${GATE_URL})" >> /tmp/_badges.md
          SONAR_KEY="github_poc-task-manager-herooffer-ghc"
          for metric in alert_status coverage bugs vulnerabilities code_smells sqale_rating reliability_rating security_rating; do
            case $metric in
              alert_status) label="Sonar Quality Gate";;
              coverage) label="Sonar Coverage";;
              bugs) label="Sonar Bugs";;
              vulnerabilities) label="Sonar Vulnerabilities";;
              code_smells) label="Sonar Code Smells";;
              sqale_rating) label="Sonar Maintainability";;
              reliability_rating) label="Sonar Reliability";;
              security_rating) label="Sonar Security";;
            esac
            echo "![${label}](https://sonarcloud.io/api/project_badges/measure?project=${SONAR_KEY}&metric=${metric})" >> /tmp/_badges.md
          done
          echo "<!-- BADGES-AUTO-END -->" >> /tmp/_badges.md
          if grep -q 'BADGES-AUTO-START' README.md; then
            sed -i '/BADGES-AUTO-START/,/BADGES-AUTO-END/d' README.md
          fi
          if grep -n '^# ' README.md >/dev/null; then
            awk 'NR==1{print; system("cat /tmp/_badges.md"); next} {print}' README.md > README.new && mv README.new README.md
          else
            cat /tmp/_badges.md README.md > README.new && mv README.new README.md
          fi
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add README.md || true
          if git diff --cached --quiet; then
            echo "README unchanged"
          else
            git commit -m "docs(badges): update dynamic badges block (${HEAD_BRANCH})" || true
          fi
      - name: Push README update
        run: |
          git push origin HEAD:${GITHUB_REF_NAME:-${{ github.event.workflow_run.head_branch }}} || echo "Push skipped"

# Próximo workflow (Build) dispara via workflow_run.
