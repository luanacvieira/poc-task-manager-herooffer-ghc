name: "ðŸ·ï¸ Auto Label PR & Issues"

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issues:
    types: [opened, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: ðŸ·ï¸ Auto Label by Path & Content
        uses: actions/labeler@v5
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          configuration-path: .github/labeler.yml
          sync-labels: true

      - name: ðŸŽ¯ Smart Labeling by PR Title & Content
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const title = context.payload.pull_request?.title || context.payload.issue?.title || '';
            const body = context.payload.pull_request?.body || context.payload.issue?.body || '';
            const content = (title + ' ' + body).toLowerCase();
            
            const labels = [];
            
            // ðŸŽ¯ Tipo de mudanÃ§a por tÃ­tulo/conteÃºdo
            if (title.match(/^(fix|bugfix|hotfix)\b/i) || content.includes('bug') || content.includes('erro')) {
              labels.push('bug');
            }
            if (title.match(/^(feat|feature)\b/i) || content.includes('nova funcionalidade')) {
              labels.push('feature');
            }
            if (title.match(/^(docs?)\b/i) || content.includes('documentaÃ§Ã£o')) {
              labels.push('documentation');
            }
            if (title.match(/^(test|tests)\b/i) || content.includes('teste')) {
              labels.push('testing');
            }
            if (title.match(/^(refactor|refactoring)\b/i) || content.includes('refatoraÃ§Ã£o')) {
              labels.push('refactoring');
            }
            if (title.match(/^(perf|performance)\b/i) || content.includes('performance')) {
              labels.push('performance');
            }
            if (title.match(/^(deps|dependencies)\b/i) || content.includes('dependÃªncia')) {
              labels.push('dependencies');
            }
            if (title.match(/^(ci|cd|workflow)\b/i) || content.includes('ci/cd')) {
              labels.push('ci-cd');
            }
            
            // ðŸš¨ Prioridade por palavras-chave
            if (content.match(/\b(urgent|crÃ­tico|critical|hotfix|blocker)\b/i)) {
              labels.push('priority:critical');
            } else if (content.match(/\b(high|alta|importante|important)\b/i)) {
              labels.push('priority:high');
            } else if (content.match(/\b(low|baixa|minor|pequena)\b/i)) {
              labels.push('priority:low');
            } else {
              labels.push('priority:medium');
            }
            
            // ðŸ’¥ Breaking changes
            if (content.match(/\b(breaking|breaking change|incompatÃ­vel)\b/i)) {
              labels.push('breaking-change');
            }
            
            // ðŸ”’ Security
            if (content.match(/\b(security|vulnerabilidade|vulnerability|cve)\b/i)) {
              labels.push('security');
            }
            
            // ðŸ·ï¸ Aplicar labels
            if (labels.length > 0) {
              const issueNumber = context.payload.pull_request?.number || context.payload.issue?.number;
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: labels
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }