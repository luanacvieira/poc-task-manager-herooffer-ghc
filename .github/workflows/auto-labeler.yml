name: "🏷️ Auto Label PR & Issues"

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issues:
    types: [opened, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: 🏷️ Auto Label by Path & Content
        uses: actions/labeler@v5
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          configuration-path: .github/labeler.yml
          sync-labels: true

      - name: 🎯 Smart Labeling by PR Title & Content
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const title = context.payload.pull_request?.title || context.payload.issue?.title || '';
            const body = context.payload.pull_request?.body || context.payload.issue?.body || '';
            const content = (title + ' ' + body).toLowerCase();
            
            const labels = [];
            
            // 🎯 Tipo de mudança por título/conteúdo
            if (title.match(/^(fix|bugfix|hotfix)\b/i) || content.includes('bug') || content.includes('erro')) {
              labels.push('bug');
            }
            if (title.match(/^(feat|feature)\b/i) || content.includes('nova funcionalidade')) {
              labels.push('feature');
            }
            if (title.match(/^(docs?)\b/i) || content.includes('documentação')) {
              labels.push('documentation');
            }
            if (title.match(/^(test|tests)\b/i) || content.includes('teste')) {
              labels.push('testing');
            }
            if (title.match(/^(refactor|refactoring)\b/i) || content.includes('refatoração')) {
              labels.push('refactoring');
            }
            if (title.match(/^(perf|performance)\b/i) || content.includes('performance')) {
              labels.push('performance');
            }
            if (title.match(/^(deps|dependencies)\b/i) || content.includes('dependência')) {
              labels.push('dependencies');
            }
            if (title.match(/^(ci|cd|workflow)\b/i) || content.includes('ci/cd')) {
              labels.push('ci-cd');
            }
            
            // 🚨 Prioridade por palavras-chave
            if (content.match(/\b(urgent|crítico|critical|hotfix|blocker)\b/i)) {
              labels.push('priority:critical');
            } else if (content.match(/\b(high|alta|importante|important)\b/i)) {
              labels.push('priority:high');
            } else if (content.match(/\b(low|baixa|minor|pequena)\b/i)) {
              labels.push('priority:low');
            } else {
              labels.push('priority:medium');
            }
            
            // 💥 Breaking changes
            if (content.match(/\b(breaking|breaking change|incompatível)\b/i)) {
              labels.push('breaking-change');
            }
            
            // 🔒 Security
            if (content.match(/\b(security|vulnerabilidade|vulnerability|cve)\b/i)) {
              labels.push('security');
            }
            
            // 🏷️ Aplicar labels
            if (labels.length > 0) {
              const issueNumber = context.payload.pull_request?.number || context.payload.issue?.number;
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: labels
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }